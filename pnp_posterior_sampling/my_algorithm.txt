Input: ğ‘“_ğœƒ (ğ»,ğ‘¡)  , time_schedual  , ğ›¾,ğ‘_ğ‘”ğ‘’ğ‘›  , ğœŒ , ğ‘Œ , delta_t , lambda
Initializations: estimate ğœÂ Ì‚_ğ», ğ‘¡_0  , ğ›¿ , rho
While ğ‘¡>0:
     ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡â†ğ‘¡âˆ’ğ‘Ÿğ‘œğ‘¢ğ‘›ğ‘‘(ğ‘¡_0/ğ‘_ğ‘”ğ‘’ğ‘› )
     ğ»_(0|ğ‘¡)â†ğ‘“_ğœƒ (ğ»_ğ‘¡,ğ‘¡)
     ğ»_(0|ğ‘¡)^â€²â†ğ»_(0|ğ‘¡)+1/ğœÂ Ì‚_ğ»  ğœŒ(ğ‘Œâˆ’ğœÂ Ì‚_ğ» ğ»_(0|ğ‘¡) ğ‘‘ğ‘–ğ‘ğ‘”(ğ‘¥))ğ‘‘ğ‘–ğ‘ğ‘”(ğ‘¥)^H
     ğœ–Â Ìƒ_ğ‘¡â†(ğ»_ğ‘¡âˆ’âˆš(ğ›¼bar_ğ‘¡ ) ğ»_(0|ğ‘¡)^â€² )/âˆš(1âˆ’ğ›¼bar_ğ‘¡ )
     ğ»_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ )â†âˆš(ğ›¼Â Ì…_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ ) ) ğ»_(0|ğ‘¡)^â€²+âˆš(1âˆ’ğ›¼Â Ì…_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ ) ) ğœ”_ğ‘¡ ğœ–Â Ìƒ_ğ‘¡
     ğ»_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ )â†ğ»Â Ì…_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ )/â€–ğ»Â Ì…_(ğ‘¡_ğ‘›ğ‘’ğ‘¥ğ‘¡ ) â€–_RMS

Return ğœÂ Ì‚_ğ» ğ»_(ğ‘¡_ğ‘“ğ‘–ğ‘›ğ‘ğ‘™ )

initializations: 
1) estimation of channel gain ğœÂ Ì‚_ğ»=â€–ğ‘Œ_0 â€–_ğ‘“ğ‘Ÿğ‘œ/âˆš(ğ‘_ğ‘ ğ‘_ğ‘ ) 
2) estimate initial time step from the average energy and diffusion scheduale: 
   alpha_target = |P|/(Nc*avg_energy)
   t_0 = argmin_t {alphabar_t<=alpha_target}
   where |P| is the cardinallity of each subset of indices meanining 
   |P| = nuber of pilots, P is a subset of indices where pilots are
   Nc = number of carrirers
   avg_energy = mean[1 + sigma^2_n / sigma^2_H]
   sigma_n^2=noise_power*sigma_H^2 where noise_power depends on user configuration  
3) set gamma and compute delta: 
   delta = sqrt(1 - gamma^2)
3) set initial channel according to columns:
   h_i^(t_0) = gamma * (y_i / (sigma_H*x_i)) + delta * epsilon_i   for i in P
   h_i^(t_0) = delta * epsilon_i                                   for i in D
   where h_i is column in a particle, and epsiloni_i ~ CN(0,I)
4) set rho: rho = 1 - (lambda*delta_t)/(1+lambda)
5) time_sqedual is the computation os the alphas ans alphabars

simulate recieved signal Y:
1) buils x in shape 64x1
   P=[0,4,8,...,60] 16 pilots in fixes intervals
   D={rest of the indices in x}
   x_i = 1 id i in P , random QPSK if i in D
2) generate N in shape 32x64 as gaussian additive noise, with noise_power that defines tha variance of the noise
3) simulate channel model: Y = H @ diag(x) + N

hyperparameters: 
- delta_t in [0, 1] controls the linear fusion between strict (GAP) and soft (HQS) data constraints
  Start with a high value (close to 1) to let the Diffusion Prior lead early on, and decrease it toward 0 to enforce strict pilot consistency
- lambda > 0: balances the regularization of the least-squares problem
  typically set $\lambda$ based on the Signal-to-Noise Ratio (SNR) of your received signal
- rho: allows the fused update to be interpreted as a preconditioned gradient descent step.
- N_gen: number of diffusion steps used to calculate the step size, usually 100